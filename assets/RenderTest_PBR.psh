#include "BasicStructures.fxh"
//#include "GLTF_PBR_Shading.fxh"
//#include "ToneMapping.fxh"

Texture2D g_DiffTexture;
Texture2D g_NormTexture;
Texture2D g_RougTexture;
Texture2D g_MetalTexture;
SamplerState g_DiffTexture_sampler; // By convention, texture samplers must use the '_sampler' suffix

TextureCube g_IrradianceMap;
TextureCube g_PrefilteredEnvMap;
Texture2D g_BRDF_LUT;


#define PI      3.14159265359
#define PI_DIV2 1.57079632679

struct UBO
{
    float4x4 g_WorldViewProj;
    float4x4 g_projection;
    float4x4 g_model;
    float4x4 g_view;
    float3 g_camPos;
    
};

cbuffer ubo : register(b0)
{
    UBO ubo;
}

cbuffer cbLightAttribs
{
    LightAttribs g_LightAttribs;
}

struct PSInput
{
    float4 Pos : SV_POSITION;
    float3 WorldPos : WORLD_POS;
    float2 UV : TEX_COORD;
    float3 Normal : NORMAL;
    float3 Tangent : TANGENT;
    float3 BiTangent : BITANGENT;
    float3x3 tangentBasis : TBASIS;
};

float3 ReconstructNormal(float4 sampleNormal, float intensity)
{
    float3 tangentNormal;
    tangentNormal.xy = (sampleNormal.rg * 2 - 1) * intensity;
    tangentNormal.z = sqrt(1 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));
    return tangentNormal;
}



float3 UnpackNormals(float2 uv, float3 viewDirection, Texture2D _normalMap,
SamplerState samplerState, float3 normal, float intensity)
{
float3 tangentNormal = ReconstructNormal(_normalMap.Sample(samplerState, uv), intensity);

float3 dPdx = ddx(viewDirection);
float3 dPdy = ddy(viewDirection);
float2 dUVdx = ddx(uv);
float2 dUVdy = ddy(uv);

float3 N = normalize(normal);
float3 crossPdyN = cross(dPdy, N);
float3 crossNPdx = cross(N, dPdx);

float3 T = crossPdyN * dUVdx.x + crossNPdx * dUVdy.x;
float3 B = crossPdyN * dUVdx.y + crossNPdx * dUVdy.y;

float invScale = rsqrt(max(dot(T, T), dot(B, B)));

    float3x3 TBN = float3x3(T * invScale, B * invScale, N);
	return normalize(mul(tangentNormal, TBN));
}

//
// LIGHTING FUNCTIONS
//
float3 FresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)
{
    float3 ret = float3(0.0, 0.0, 0.0);
    float powTheta = pow(1.0 - cosTheta, 5.0);
    float invRough = float(1.0 - roughness);

    ret.x = F0.x + (max(invRough, F0.x) - F0.x) * powTheta;
    ret.y = F0.y + (max(invRough, F0.y) - F0.y) * powTheta;
    ret.z = F0.z + (max(invRough, F0.z) - F0.z) * powTheta;

    return ret;
}

float3 FresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0f - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(float3 N, float3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0f);
    float k = (r * r) / 8.0f;

    float nom = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}


float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

float3 OrenNayarDiffuse(float3 L, float3 V, float3 N, float roughness, float3 albedo, float3 kD)
{
	// src: https://www.gamasutra.com/view/feature/131269/implementing_modular_hlsl_with_.php?page=3

    const float NdotL = max(dot(N, L), 0.0f);
    const float NdotV = max(dot(N, V), 0.0f);

	// gamma: the azimuth (circular angle) between L and V
	//
    const float gamma = max(0.0f, dot(normalize(V - N * NdotV), normalize(L - N * NdotL)));

	// alpha and beta represent the polar angles in spherical coord system
	//
	// alpha = min(theta_L, theta_V)
	// beta  = max(theta_L, theta_V)
	//
	// where theta_L is the angle between N and L
	//   and theta_V is the angle between N and V
	//
    const float alpha = max(acos(NdotV), acos(NdotL));
    const float beta = min(acos(NdotV), acos(NdotL));

    const float sigma2 = roughness * roughness;

	// Oren-Nayar constants
    const float A = 1.0f - 0.5f * sigma2 / (sigma2 + 0.33f);
    float B = 0.45f * sigma2 / (sigma2 + 0.09f);
    if (gamma >= 0)
        B *= sin(alpha) * clamp(tan(beta), -PI_DIV2, PI_DIV2);
    else
        B = 0.0f;

    return (A + B) * albedo * kD / PI;
}


float3 BRDF(float3 N, float3 V, float3 L, float3 albedo, float roughness, float metalness, int isOrenNayar)
{
    const float3 H = normalize(V + L);

	// F0 represents the base reflectivity (calculated using IOR: index of refraction)
    float3 F0 = float3(0.04f, 0.04f, 0.04f);
    F0 = lerp(F0, albedo, metalness);

    float NDF = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    float3 F = FresnelSchlick(max(dot(N, H), 0.0f), F0);

    float3 kS = F;
    float3 kD = (float3(1.0f, 1.0f, 1.0f) - kS) * (1.0f - metalness);

	// Id & Is: diffuse & specular illumination
    float3 Is = NDF * G * F / (4.0f * max(dot(N, V), 0.0f) * max(dot(N, L), 0.0f) + 0.001f);
    float3 Id = float3(0, 0, 0);
    
    Id = OrenNayarDiffuse(L, V, N, roughness, albedo, kD);

    return Id + Is;
}

float3 EnvironmentBRDF(float3 N, float3 V, float3 albedo, float roughness, float metalness)
{
    const float3 R = reflect(-V, N);

	// F0 represents the base reflectivity (calculated using IOR: index of refraction)
    float3 F0 = float3(0.04f, 0.04f, 0.04f);
    F0 = lerp(F0, albedo, metalness);

    float3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0f), F0, roughness);

    float3 kS = F;
    float3 kD = (float3(1.0f, 1.0f, 1.0f) - kS) * (1.0f - metalness);

    float3 irradiance = g_IrradianceMap.Sample(g_DiffTexture_sampler, N).rgb; //SampleTexCube(Get(irradianceMap), Get(bilinearSampler), N).rgb;
    float3 specular = g_PrefilteredEnvMap.SampleLevel(g_DiffTexture_sampler, R, roughness * 4).rgb; //SampleLvlTexCube(Get(specularMap), Get(bilinearSampler), R, roughness * 4).rgb;

    float2 maxNVRough = float2(max(dot(N, V), 0.0), roughness);
    float2 brdf = g_BRDF_LUT.Sample(g_DiffTexture_sampler, maxNVRough).rg; //SampleTex2D(Get(brdfIntegrationMap), Get(bilinearClampedSampler), maxNVRough).rg;

	// Id & Is: diffuse & specular illumination
    float3 Is = specular * (F * brdf.x + brdf.y);
    float3 Id = kD * irradiance * albedo;
	
	//if (isOrenNayar)
	//	Id = OrenNayarDiffuse(L, V, N, roughness, albedo, kD);
	//else
	//	Id = LambertDiffuse(albedo, kD);

    return (Id + Is);
}

float4 main(in PSInput input, in bool IsFrontFace : SV_IsFrontFace) : SV_Target
{   
    float4 Out;
    
    const float3 P = input.WorldPos.xyz;
    const float3 V = normalize(ubo.g_camPos.xyz - P);
    const float2 uv = input.UV;
    
    
    float3 _albedo = g_DiffTexture.Sample(g_DiffTexture_sampler, input.UV).rgb;
    float _roughness = g_RougTexture.Sample(g_DiffTexture_sampler, input.UV).r;
    if (_roughness < 0.04)
        _roughness = 0.04;
    const float _metalness = g_MetalTexture.Sample(g_DiffTexture_sampler, input.UV).r;
    const float _ao = 1.0f;
    float3 N = UnpackNormals(input.UV, -V, g_NormTexture, g_DiffTexture_sampler, input.Normal, 1);
    
    float3 Lo = float3(0.0f, 0.0f, 0.0f); // outgoing radiance
    
    //DIRECTINNAL LIGHT
    const float3 L = -g_LightAttribs.f4Direction.xyz;
    const float NdotL = max(dot(N, L), 0.0f);
    const float3 colorLight = g_LightAttribs.f4Intensity.rgb;
    const float intensity = g_LightAttribs.f4Intensity.a;
    const float3 radiance = colorLight * intensity;

    Lo += BRDF(N, V, L, _albedo, _roughness, _metalness, true) * radiance * NdotL;
    
    float aoWithIntensity = _ao * 0.1f + (1.0f - 0.1f);
    Lo += EnvironmentBRDF(N, V, _albedo, _roughness, _metalness) * float3(aoWithIntensity, aoWithIntensity, aoWithIntensity) * 1.0;
    
    float3 color = Lo;
    // Tone mapping
    color = color / (color + float3(1.0f, 1.0f, 1.0f));
    
    Out = float4(color.r, color.g, color.b, 1.0f);
    return Out;
}